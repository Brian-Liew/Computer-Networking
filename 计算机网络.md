### 计算机网络：

#### UDP和TCP的区别：（三个点：连接、报文、可靠）

TCP是面向连接的，UDP是面向无连接的；

UDP程序结仇简单

TCP是面向字节流，UDP是面向数据报的；

TCP保证数据正确性，UDP可能丢包；

TCP保证数据顺序，UDP不保证；

###### 总体的回答：

TCP是面向连接，可靠的字节流服务，也就是客户和服务器在交换数据前，必须建立一个TCP连接，之后再传输数据，并且提供超时重发，丢弃重复数据，检验数据，流量控制，保证数据从一端送到另一端。UDP是简单的数据报传输层协议，支持把应用程序传给IP层地数据报发送出去，不能保证目的地。因为在两端没有建立连接，没有超时重发，所以传输速度较快。

###### 什么是可靠连接：

通过TCP连接传输的数据无差错、不丢失、不重复、且按顺序到达

TCP报文头里面的序号能保证数据按顺序到达

报文头里面的确认序号能保证不丢包，累积确认以及超时重传机制

TCP有流量控制以及拥塞控制的机制

##### TCP的顺序问题、丢包问题、流量控制都是通过滑动窗口解决；而拥塞控制则是通过拥塞窗口来解决。

##### 个人觉得比较好说：

UDP没有建立与目的端的连接，是无连接的传输服务，同时是没有确认机制、也没有重传机制，不知道是否成功传到目的端，同时也是面向数据报，应用层交给它什么报文，就原封发送，不拆分也不合并。

##### UDP：

报文最大64K长度，超过需要应用层手动分包，UDP不包序，需要在应用层进行编号。

应用：直播（宁丢包也不要卡顿）

实时游戏：实时性高

物联网：代价小

##### NFS：网络文件系统，多种服务器之间数据共享，不同主机可以共享文件以及目录。

##### TFTP：基于UDP协议的简单传输文件协议，端口号69

##### DHCP：动态主机设置协议，内部网自动分配IP地址，给用户用于内部网管理的手段。

##### DNS：域名解析协议

##### TCP：

三次握手：主机A向B发送一个含有同步序列号标志位的数据段（SYN），主机B收到请求后发送带有确认应答（ACK）和同步序列号（SYN）的数据段，最后收到后A再发送一个确认应答；

四次挥手：主机完成数据传输，将控制位FIN置1，提出停止连接请求，B收到后将ACK置1，将FIN

置1，主机A收到后将ACK置1，双方都关闭。

###### 确认应答：

每个字节数据进行编号，每个ACK都确认序列号，告诉发送到哪个数据。

###### 超时重传：

A发送的数据可能因为网络原因没能到达，主机A没有收到应答会重发，同时A没收到应答可能是因为没能得到B传回的ACK，B需要将接收到的重复报丢掉。

###### 拥塞控制：

为了控制包丢失以及超市重传，先慢启动，越来越快，设置一个阈值，当超过这个阈值就慢下来，但仍然实在增长，等到出现拥塞，需要降低速度，将速度降为一半，再重复上述流程。

###### 滑动窗口：

发送窗口内数据无需确认，直接发送，收到第一个ACK就往后移动窗口，能确认当前窗口的数据都被收到。

###### 流量控制：

在接收端放置一个窗口大小的字段，一旦发现缓冲区太小就设置更小的值给发送端。



#### Http与Https的区别：

http是超文本传输协议，信息是明文传输，https是具有安全性的ssl加密传输协议；

他们端口不一样，一个80，一个443；

http是简单的连接，无状态，https是加密传输、身份认证，更加安全。



#### 计算机网络的分类：

按范围分：WAN、MAN、LAN、PAN注意英文对应的名称；

按交换技术分类：报文交换、分组交换的区别？



#### 三次握手的必要性：

> 考虑一次的问题，首先tcp是面向连接，一次握手肯定建立不了连接，因为客户机给服务器发出请求信息却没有得到回应，客户机是没法判定是否发送成功然后建立连接的。
>
> 再看两次，假设只有两次握手，比如图中的1，2步，当A想要建立连接时发送一个SYN，然后等待ACK，结果这个SYN因为网络问题没有及时到达B，所以A在一段时间内没收到ACK后，再发送一个SYN，这次B顺利收到，接着A也收到ACK，这时A发送的第一个SYN终于到了B，对于B来说这是一个新连接请求，然后B又为这个连接申请资源，返回ACK，然而这个SYN是个无效的请求，A收到这个SYN的ACK后也并不会理会它，而B却不知道，B会一直为这个连接维持着资源，造成资源的浪费。
>
> 三次连接就没毛病了？？是的
>
> 两次握手的问题在于服务器端不知道一个SYN是否是无效的，而三次握手机制因为客户端会给服务器回复第二次握手，也意味着服务器会等待客户端的第三次握手，如果第三次握手迟迟不来，服务器便会认为这个SYN是无效的，释放相关资源。但这时有个问题就是客户端完成第二次握手便认为连接已建立，而第三次握手可能在传输中丢失，服务端会认为连接是无效的，这时如果Client端向Server写数据，Server端将以RST包响应，这时便感知到Server的错误。
>
> 总之，三次握手可以保证任何一次握手的失败都是可感知的，不会浪费资源
>
> 三次握手出现错误时的应对措施
>
>      第一次握手A发送SYN传输失败，A,B都不会申请资源，连接失败。如果一段时间内发出多个SYN连接请求，那么A只会接受它最后发送的那个SYN的SYN+ACK回应，忽略其他回应全部回应，B中多申请的资源也会释放
>    
>      第二次握手B发送SYN+ACK传输失败，A不会申请资源，B申请了资源，但收不到A的ACK，过一段时间释放资源。如果是收到了多个A的SYN请求，B都会回复SYN+ACK，但A只会承认其中它最早发送的那个SYN的回应，并回复最后一次握手的ACK
>    
>      第三次握手ACK传输失败，B没有收到ACK，释放资源，对于后序的A的传输数据返回RST。实际上B会因为没有收到A的ACK会多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到A的ACK，则释放资源，对A的数据传输返回RST
> ————————————————
> 原文链接：https://blog.csdn.net/u013344815/article/details/72134950
>
> 

总结起来就是避免对于之前无效的请求建立无效的连接。



#### OSI模型（开放系统互联参考模型）：

![osi模型](F:\markdown\osi模型.jpg)

|            | 单位                   | 任务                                   | 功能                                                         | 标准                                 |
| ---------- | ---------------------- | -------------------------------------- | ------------------------------------------------------------ | ------------------------------------ |
| 物理层     | 比特                   | 透明传输                               | 在物理媒体上为数据端透明传输原始比特流                       | 232c...                              |
| 数据链路层 | 帧                     | 将网络层的IP数据报组装成帧             | 成帧、差错控制、流量控制、传输管理                           | SDLC、HDLC、PPP、STP                 |
| 网络层     | 数据报                 | 把协议数据单元（分组）从源端传到目的端 | 流量控制、拥塞控制、差错控制、网际互联、路由选择             | IP、IPX、ICMP、ARP、RARP、IGMP、OSPF |
| 传输层     | 报文段或数据报（分组） | 主机中两个进程之间的通信               | 端对端连接可靠传输、流量控制、差错控制、服务质量、数据传输管理 | TCP、UDP                             |
| 会话层     |                        | 也是各个进程间会话                     | 利用传输层的段对端服务，，提供增值服务，建立同步，管理进程会话 |                                      |
| 表示层     |                        | 通信的交换信息方式                     | 编码、数据压缩、加密、解密                                   |                                      |
| 应用层     |                        | 用户与网络的界面                       |                                                              | HTTP、SMTP、FTP                      |

![tcp](F:\markdown\tcp.jpg)



